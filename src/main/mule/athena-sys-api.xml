<?xml version="1.0" encoding="UTF-8"?>
<mule xmlns:db="http://www.mulesoft.org/schema/mule/db"
      xmlns:ee="http://www.mulesoft.org/schema/mule/ee/core"
      xmlns:http="http://www.mulesoft.org/schema/mule/http"
      xmlns:aws-s3="http://www.mulesoft.org/schema/mule/aws-s3"
      xmlns="http://www.mulesoft.org/schema/mule/core"
      xmlns:doc="http://www.mulesoft.org/schema/mule/documentation"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="
          http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
          http://www.mulesoft.org/schema/mule/db http://www.mulesoft.org/schema/mule/db/current/mule-db.xsd
          http://www.mulesoft.org/schema/mule/ee/core http://www.mulesoft.org/schema/mule/ee/core/current/mule-ee.xsd
          http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd
          http://www.mulesoft.org/schema/mule/aws-s3 http://www.mulesoft.org/schema/mule/aws-s3/current/mule-aws-s3.xsd">

    <configuration-properties file="application.properties" />

    <!-- Database Connector Configuration for AWS Athena -->
    <db:generic-config name="AthenaDatabaseConfig" 
                       driverClassName="com.simba.athena.jdbc.Driver"
                       url="#[p('aws.region') != empty ? 
                            'jdbc:awsathena://AwsRegion=' ++ p('aws.region') ++ 
                            ';S3OutputLocation=' ++ p('aws.s3.output.location') ++ 
                            (p('aws.athena.workgroup') != empty ? ';Workgroup=' ++ p('aws.athena.workgroup') : '') ++ ';'
                            : 'jdbc:awsathena://AwsRegion=us-east-1;S3OutputLocation=s3://your-bucket/results/;']"
                       user="#[p('aws.access.key')]"
                       password="#[p('aws.secret.key')]"
                       doc:name="Athena Database Config">
        <db:pool>
            <db:connection-pooling-profile initialSize="#[p('db.pool.initialSize')]"
                                           minSize="#[p('db.pool.minSize')]"
                                           maxSize="#[p('db.pool.maxSize')]"
                                           idleTimeout="#[p('db.pool.idleTimeout')]"
                                           maxWait="#[p('db.pool.maxWait')]"
                                           connectionTimeout="#[p('db.pool.connectionTimeout')]"/>
        </db:pool>
        <db:driver-property key="queryTimeout" value="#[p('db.query.timeout')]"/>
        <db:connection-properties>
            <db:connection-property key="SSL" value="#[p('db.ssl.enabled') == 'true' ? '1' : '0']"/>
            <db:connection-property key="SSLTrustStore" value="#[p('db.ssl.enabled') == 'true' and p('db.ssl.trustStorePath') != empty ? p('db.ssl.trustStorePath') : '']"/>
        </db:connection-properties>
    </db:generic-config>

    <!-- HTTP Listener Configuration -->
    <http:listener-config name="HTTP_Listener_config" 
                          host="#[p('http.host')]" 
                          port="#[p('http.port')]"
                          doc:name="HTTP Listener configuration">
        <http:response-builder>
            <http:headers><![CDATA[#[output application/java
---
{
    "Content-Type" : "application/json"
}]]]></http:headers>
        </http:response-builder>
    </http:listener-config>

    <!-- AWS S3 Connector Configuration -->
    <aws-s3:config name="AWS_S3_Config"
                   accessKeyId="#[p('aws.access.key')]"
                   secretAccessKey="#[p('aws.secret.key')]"
                   region="#[p('aws.region')]"
                   doc:name="AWS S3 Config"/>

    <!-- HTTP Request Configuration for Athena REST API -->
    <http:request-config name="AthenaRESTAPI_Request_configuration"
                         basePath="/"
                         host="athena.#[p('aws.region')].amazonaws.com"
                         protocol="HTTPS"
                         port="443"
                         doc:name="Athena REST API Request configuration">
        <http:request-builder>
            <http:headers><![CDATA[#[output application/java
---
{
    "Content-Type" : "application/x-amz-json-1.1",
    "X-Amz-Target" : "AmazonAthena.StartQueryExecution"
}]]]></http:headers>
        </http:request-builder>
    </http:request-config>

    <!-- Global Error Handler -->
    <error-handler name="GlobalErrorHandler">
        <on-error-continue type="DB:QUERY_EXECUTION" logException="true" doc:name="Query Execution Error">
            <logger level="ERROR" message="Athena query execution error: #[error.description]" doc:name="Log Query Error"/>
            <ee:transform doc:name="Error Response">
                <ee:message>
                    <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    "error": "QUERY_EXECUTION_ERROR",
    "errorCode": "ATHENA_QUERY_FAILED",
    "message": error.description,
    "cause": error.cause.message default "",
    "troubleshooting": [
        "Check query syntax in AWS Athena Console",
        "Verify table and column names exist",
        "Check IAM permissions for Athena and S3",
        "Review query timeout settings (db.query.timeout)",
        "For large queries, consider using async endpoint or CTAS pattern"
    ],
    "documentation": "See README Troubleshooting section for detailed guidance"
}]]></ee:set-payload>
                </ee:message>
                <ee:set-status-code value="500"/>
            </ee:transform>
        </on-error-continue>
        
        <on-error-continue type="DB:CONNECTIVITY" logException="true" doc:name="Connectivity Error">
            <logger level="ERROR" message="Athena connectivity error: #[error.description]" doc:name="Log Connectivity Error"/>
            <ee:transform doc:name="Error Response">
                <ee:message>
                    <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    "error": "CONNECTIVITY_ERROR",
    "errorCode": "ATHENA_CONNECTION_FAILED",
    "message": "Unable to connect to AWS Athena. Please check your credentials and network connectivity.",
    "cause": error.cause.message default "",
    "troubleshooting": [
        "Verify AWS credentials in application.properties or environment variables",
        "Check network connectivity to AWS (firewall, VPC settings)",
        "Verify IAM permissions for Athena service",
        "Ensure TLS 1.2+ support (required for CloudHub 2.0)",
        "For CloudHub 2.0: Whitelist Private Space static IPs in AWS",
        "Test connectivity: aws athena list-work-groups --region us-east-1"
    ],
    "documentation": "See README Security Considerations and Troubleshooting sections"
}]]></ee:set-payload>
                </ee:message>
                <ee:set-status-code value="503"/>
            </ee:transform>
        </on-error-continue>

        <on-error-continue type="HTTP:BAD_REQUEST" logException="true" doc:name="Bad Request Error">
            <logger level="WARN" message="Bad request: #[error.description]" doc:name="Log Bad Request"/>
            <ee:transform doc:name="Error Response">
                <ee:message>
                    <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    "error": "BAD_REQUEST",
    "message": error.description
}]]></ee:set-payload>
                </ee:message>
                <ee:set-status-code value="400"/>
            </ee:transform>
        </on-error-continue>

        <on-error-continue type="EXPRESSION" logException="true" doc:name="Expression Error">
            <logger level="ERROR" message="Expression error: #[error.description]" doc:name="Log Expression Error"/>
            <ee:transform doc:name="Error Response">
                <ee:message>
                    <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    "error": "EXPRESSION_ERROR",
    "message": error.description
}]]></ee:set-payload>
                </ee:message>
                <ee:set-status-code value="500"/>
            </ee:transform>
        </on-error-continue>
    </error-handler>

    <!-- Synchronous Query Flow -->
    <flow name="synchronousQueryFlow" doc:name="synchronousQueryFlow">
        <http:listener path="#[p('api.base.path')]/query" 
                       config-ref="HTTP_Listener_config" 
                       allowedMethods="POST" 
                       doc:name="Synchronous Query Endpoint"/>
        
        <ee:transform doc:name="Extract Query and Pagination">
            <ee:message>
                <ee:set-variable variableName="baseQuery"><![CDATA[%dw 2.0
output application/java
---
payload.query default ""]]></ee:set-variable>
                <ee:set-variable variableName="lastSeenId"><![CDATA[%dw 2.0
output application/java
---
payload.lastSeenId default ""]]></ee:set-variable>
                <ee:set-variable variableName="limit"><![CDATA[%dw 2.0
output application/java
---
payload.limit default p('pagination.defaultLimit')]]></ee:set-variable>
                <ee:set-variable variableName="idColumn"><![CDATA[%dw 2.0
output application/java
---
p('pagination.idColumn')]]></ee:set-variable>
            </ee:message>
        </ee:transform>

        <ee:transform doc:name="Validate Input">
            <ee:message>
                <ee:set-variable variableName="validationErrors"><![CDATA[%dw 2.0
output application/java
---
do {
    var errors = []
    
    // Validate query is not empty
    if (vars.baseQuery == empty or vars.baseQuery == null)
        errors = errors + "Query parameter is required"
    
    // Validate query length (prevent extremely long queries)
    if (sizeOf(vars.baseQuery) > 100000)
        errors = errors + "Query exceeds maximum length of 100,000 characters"
    
    // Validate lastSeenId format (must be numeric if provided)
    if (vars.lastSeenId != empty and vars.lastSeenId != null)
        if (vars.lastSeenId as Number? == null)
            errors = errors + "lastSeenId must be a numeric value"
    
    // Validate limit (must be positive and within max limit)
    var maxLimit = p('pagination.maxLimit') as Number
    if (vars.limit as Number? != null)
        if (vars.limit as Number <= 0)
            errors = errors + "Limit must be a positive number"
        else if (vars.limit as Number > maxLimit)
            errors = errors + "Limit exceeds maximum of " ++ maxLimit
    
    // Basic SQL injection prevention - check for dangerous patterns
    var upperQuery = upper(vars.baseQuery)
    var dangerousPatterns = ["DROP TABLE", "DELETE FROM", "TRUNCATE", "ALTER TABLE", "CREATE USER", "GRANT ALL"]
    var foundDangerous = dangerousPatterns filter (pattern) -> upperQuery contains pattern
    
    if (sizeOf(foundDangerous) > 0)
        errors = errors + "Query contains potentially dangerous SQL operations: " ++ (foundDangerous joinBy ", ")
    
    errors
}]]></ee:set-variable>
            </ee:message>
        </ee:transform>

        <choice doc:name="Check Validation Errors">
            <when expression="#[sizeOf(vars.validationErrors) > 0]">
                <ee:transform doc:name="Validation Error Response">
                    <ee:message>
                        <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    "error": "VALIDATION_ERROR",
    "message": "Input validation failed",
    "errors": vars.validationErrors,
    "errorCode": "INVALID_INPUT"
}]]></ee:set-payload>
                        </ee:message>
                        <ee:set-status-code value="400"/>
                    </ee:transform>
            </when>
        </choice>

        <ee:transform doc:name="Build Query with Cursor Pagination">
            <ee:message>
                <ee:set-variable variableName="sqlQuery"><![CDATA[%dw 2.0
output application/java
---
if (vars.lastSeenId != empty and vars.lastSeenId != null) 
    do {
        // Strip comments to avoid false matches in WHERE detection
        // Remove single-line comments (-- comment)
        var queryNoComments = vars.baseQuery replace /--[^\r\n]*/ with ""
        // Remove multi-line comments (/* comment */)
        var queryCleaned = queryNoComments replace /\/\*[\s\S]*?\*\// with ""
        
        // Convert to uppercase for case-insensitive matching
        var upperQuery = upper(queryCleaned)
        
        // Enhanced WHERE detection - strip comments first, then use case-insensitive search
        // This handles most edge cases (comments, but not complex subqueries)
        // For complex queries with subqueries, manual WHERE clause management may be needed
        var hasWhere = upperQuery contains " WHERE "
        
        // Check for ORDER BY and LIMIT
        var hasOrderBy = upperQuery contains " ORDER BY "
        var hasLimit = upperQuery contains " LIMIT "
        
        var cursorCondition = vars.idColumn ++ " > " ++ vars.lastSeenId
        
        // Build query with cursor condition
        // Simple approach: if WHERE exists, append AND; otherwise add WHERE
        // This works for most common cases. Complex queries with subqueries may need manual handling.
        var queryWithCursor = if (hasWhere)
            // Find position before ORDER BY or LIMIT to insert AND condition
            var orderByIdx = upperQuery indexOf " ORDER BY "
            var limitIdx = upperQuery indexOf " LIMIT "
            var insertIdx = if (orderByIdx > 0 and limitIdx > 0) min([orderByIdx, limitIdx])
                           else if (orderByIdx > 0) orderByIdx
                           else if (limitIdx > 0) limitIdx
                           else sizeOf(queryCleaned)
            
            if (insertIdx < sizeOf(queryCleaned))
                queryCleaned[0 to insertIdx] ++ " AND " ++ cursorCondition ++ " " ++ queryCleaned[insertIdx to -1]
            else
                queryCleaned ++ " AND " ++ cursorCondition
        else
            // No WHERE clause - add one before ORDER BY, LIMIT, or at end
            var orderByIdx = upperQuery indexOf " ORDER BY "
            var limitIdx = upperQuery indexOf " LIMIT "
            var insertIdx = if (orderByIdx > 0 and limitIdx > 0) min([orderByIdx, limitIdx])
                           else if (orderByIdx > 0) orderByIdx
                           else if (limitIdx > 0) limitIdx
                           else sizeOf(queryCleaned)
            
            if (insertIdx < sizeOf(queryCleaned))
                queryCleaned[0 to insertIdx] ++ " WHERE " ++ cursorCondition ++ " " ++ queryCleaned[insertIdx to -1]
            else
                queryCleaned ++ " WHERE " ++ cursorCondition
        
        // Add ORDER BY if not present
        var queryWithOrder = if (hasOrderBy)
            queryWithCursor
        else
            var upperWithCursor = upper(queryWithCursor)
            var limitIdxNew = upperWithCursor indexOf " LIMIT "
            if (limitIdxNew > 0)
                queryWithCursor[0 to limitIdxNew] ++ " ORDER BY " ++ vars.idColumn ++ " " ++ queryWithCursor[limitIdxNew to -1]
            else
                queryWithCursor ++ " ORDER BY " ++ vars.idColumn
        
        // Add LIMIT if not present
        var finalQuery = if (hasLimit)
            queryWithOrder
        else
            queryWithOrder ++ " LIMIT " ++ vars.limit
        
        finalQuery
    } else
        vars.baseQuery]]></ee:set-variable>
            </ee:message>
        </ee:transform>

        <choice doc:name="Validate Query">
            <when expression="#[vars.baseQuery == empty]">
                <ee:transform doc:name="Validation Error">
                    <ee:message>
                        <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    "error": "VALIDATION_ERROR",
    "message": "Query parameter is required"
}]]></ee:set-payload>
                        </ee:message>
                        <ee:set-status-code value="400"/>
                    </ee:transform>
            </when>
            <otherwise>
                <db:select config-ref="AthenaDatabaseConfig" doc:name="Execute Query">
                    <db:sql>#[vars.sqlQuery]</db:sql>
                </db:select>
                
                <ee:transform doc:name="Format Response with Pagination">
                    <ee:message>
                        <ee:set-variable variableName="lastRowId"><![CDATA[%dw 2.0
output application/java
---
if (sizeOf(payload) > 0)
    payload[-1][vars.idColumn] default payload[-1][upper(vars.idColumn)] default ""
else
    ""]]></ee:set-variable>
                        <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    "status": "SUCCESS",
    "query": vars.sqlQuery,
    "rowCount": sizeOf(payload),
    "results": payload,
    "lastSeenId": vars.lastRowId,
    "hasMore": sizeOf(payload) == vars.limit
}]]></ee:set-payload>
                        </ee:message>
                    </ee:transform>
                </otherwise>
        </choice>

        <error-handler>
            <on-error-continue type="DB:QUERY_EXECUTION" logException="true" doc:name="Query Execution Error">
                <choice doc:name="Check Error Type">
                    <when expression="#[error.cause.message contains 'TooManyRequestsException' or error.cause.message contains 'ThrottlingException']">
                        <logger level="WARN" message="Athena throttled - backing off" doc:name="Log Throttling"/>
                        <until-successful maxRetries="#[p('retry.maxRetries')]" 
                                         millisBetweenRetries="#[p('retry.millisBetweenRetries')]" 
                                         doc:name="Retry with Backoff">
                            <db:select config-ref="AthenaDatabaseConfig" doc:name="Retry Query">
                                <db:sql>#[vars.sqlQuery]</db:sql>
                            </db:select>
                        </until-successful>
                    </when>
                    <when expression="#[error.cause.message contains 'ICEBERG_MISSING_METADATA']">
                        <logger level="ERROR" message="Iceberg metadata error - requires operational check" doc:name="Log Iceberg Error"/>
                        <ee:transform doc:name="Iceberg Error Response">
                            <ee:message>
                                <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    "error": "ICEBERG_METADATA_ERROR",
    "errorCode": "ICEBERG_METADATA_CORRUPTED",
    "message": "Iceberg table metadata is missing or corrupted. Please contact the data engineering team.",
    "details": error.cause.message,
    "troubleshooting": [
        "Verify S3 metadata location is accessible",
        "Check for concurrent writes causing metadata conflicts",
        "Review Iceberg table metadata in S3",
        "Contact data engineering team for metadata repair",
        "Consider recreating the Iceberg table if metadata is unrecoverable"
    ],
    "documentation": "See README Troubleshooting section: ICEBERG_MISSING_METADATA error"
}]]></ee:set-payload>
                            </ee:message>
                            <ee:set-status-code value="500"/>
                        </ee:transform>
                    </when>
                </choice>
            </on-error-continue>
        </error-handler>
    </flow>

    <!-- Asynchronous Query Execution Flow -->
    <flow name="asyncQueryFlow" doc:name="asyncQueryFlow">
        <http:listener path="#[p('api.base.path')]/query/async" 
                       config-ref="HTTP_Listener_config" 
                       allowedMethods="POST" 
                       doc:name="Async Query Endpoint"/>
        
        <ee:transform doc:name="Prepare Athena Request">
            <ee:message>
                <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    "QueryString": payload.query,
    "ResultConfiguration": {
        "OutputLocation": p('aws.s3.output.location')
    },
    "WorkGroup": p('aws.athena.workgroup') default ""
}]]></ee:set-payload>
                </ee:message>
                <ee:set-variable variableName="queryString" value="#[payload.query]"/>
            </ee:transform>

        <http:request method="POST" 
                     path="/" 
                     config-ref="AthenaRESTAPI_Request_configuration" 
                     doc:name="Start Query Execution">
            <http:request-builder>
                <http:headers><![CDATA[#[output application/java
---
{
    "Content-Type" : "application/x-amz-json-1.1",
    "X-Amz-Target" : "AmazonAthena.StartQueryExecution"
}]]]></http:headers>
            </http:request-builder>
        </http:request>

        <ee:transform doc:name="Extract Execution ID">
            <ee:message>
                <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    "status": "QUEUED",
    "executionId": payload.QueryExecutionId,
    "query": vars.queryString,
    "statusEndpoint": p('api.base.path') ++ "/query/" ++ payload.QueryExecutionId ++ "/status",
    "resultsEndpoint": p('api.base.path') ++ "/query/" ++ payload.QueryExecutionId ++ "/results"
}]]></ee:set-payload>
                </ee:message>
            </ee:transform>
    </flow>

    <!-- Query Status Flow -->
    <flow name="queryStatusFlow" doc:name="queryStatusFlow">
        <http:listener path="#[p('api.base.path')]/query/{executionId}/status" 
                       config-ref="HTTP_Listener_config" 
                       allowedMethods="GET" 
                       doc:name="Query Status Endpoint"/>
        
        <ee:transform doc:name="Prepare Status Request">
            <ee:message>
                <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    "QueryExecutionId": attributes.uriParams.executionId
}]]></ee:set-payload>
                </ee:message>
            </ee:transform>

        <http:request method="POST" 
                     path="/" 
                     config-ref="AthenaRESTAPI_Request_configuration" 
                     doc:name="Get Query Execution">
            <http:request-builder>
                <http:headers><![CDATA[#[output application/java
---
{
    "Content-Type" : "application/x-amz-json-1.1",
    "X-Amz-Target" : "AmazonAthena.GetQueryExecution"
}]]]></http:headers>
            </http:request-builder>
        </http:request>

        <ee:transform doc:name="Format Status Response">
            <ee:message>
                <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    "executionId": payload.QueryExecution.QueryExecutionId,
    "status": payload.QueryExecution.Status.State,
    "query": payload.QueryExecution.Query,
    "submissionDateTime": payload.QueryExecution.Status.SubmissionDateTime,
    "completionDateTime": payload.QueryExecution.Status.CompletionDateTime default "",
    "stateChangeReason": payload.QueryExecution.Status.StateChangeReason default "",
    "dataScannedInBytes": payload.QueryExecution.Statistics.DataScannedInBytes default 0,
    "executionTimeInMillis": payload.QueryExecution.Statistics.ExecutionTimeInMillis default 0
}]]></ee:set-payload>
                </ee:message>
            </ee:transform>
    </flow>

    <!-- Query Results Flow -->
    <flow name="queryResultsFlow" doc:name="queryResultsFlow">
        <http:listener path="#[p('api.base.path')]/query/{executionId}/results" 
                       config-ref="HTTP_Listener_config" 
                       allowedMethods="GET" 
                       doc:name="Query Results Endpoint"/>
        
        <ee:transform doc:name="Prepare Results Request">
            <ee:message>
                <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    "QueryExecutionId": attributes.uriParams.executionId,
    "MaxResults": attributes.queryParams.limit default p('pagination.defaultLimit')
}]]></ee:set-payload>
                </ee:message>
            </ee:transform>

        <http:request method="POST" 
                     path="/" 
                     config-ref="AthenaRESTAPI_Request_configuration" 
                     doc:name="Get Query Results">
            <http:request-builder>
                <http:headers><![CDATA[#[output application/java
---
{
    "Content-Type" : "application/x-amz-json-1.1",
    "X-Amz-Target" : "AmazonAthena.GetQueryResults"
}]]]></http:headers>
            </http:request-builder>
        </http:request>

        <ee:transform doc:name="Format Results Response">
            <ee:message>
                <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    "executionId": attributes.uriParams.executionId,
    "resultSet": {
        "columnInfo": payload.ResultSet.ResultSetMetadata.ColumnInfo,
        "rows": payload.ResultSet.Rows map (row, index) -> {
            "rowNumber": index,
            "data": row.Data
        }
    },
    "nextToken": payload.NextToken default ""
}]]></ee:set-payload>
                </ee:message>
            </ee:transform>
    </flow>

    <!-- CTAS Pattern Flow for Large Datasets -->
    <flow name="ctasQueryFlow" doc:name="ctasQueryFlow">
        <http:listener path="#[p('api.base.path')]/query/ctas" 
                       config-ref="HTTP_Listener_config" 
                       allowedMethods="POST" 
                       doc:name="CTAS Query Endpoint"/>
        
        <ee:transform doc:name="Build CTAS Query">
            <ee:message>
                <ee:set-variable variableName="sourceQuery"><![CDATA[%dw 2.0
output application/java
---
payload.query default ""]]></ee:set-variable>
                <ee:set-variable variableName="outputTable"><![CDATA[%dw 2.0
output application/java
---
payload.outputTable default "ctas_results_" ++ now() as String {format: "yyyyMMddHHmmss"}]]></ee:set-variable>
                <ee:set-variable variableName="s3Location"><![CDATA[%dw 2.0
output application/java
---
p('aws.s3.output.location') ++ vars.outputTable ++ "/"]]></ee:set-variable>
                <ee:set-variable variableName="ctasQuery"><![CDATA[%dw 2.0
output application/java
---
"CREATE TABLE " ++ vars.outputTable ++ " WITH (format = 'PARQUET', external_location = '" ++ vars.s3Location ++ "') AS " ++ vars.sourceQuery]]></ee:set-variable>
            </ee:message>
        </ee:transform>

        <db:execute config-ref="AthenaDatabaseConfig" doc:name="Execute CTAS">
            <db:sql>#[vars.ctasQuery]</db:sql>
        </db:execute>

        <ee:transform doc:name="Extract S3 Path">
            <ee:message>
                <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    "status": "SUCCESS",
    "tableName": vars.outputTable,
    "s3Location": vars.s3Location,
    "message": "CTAS query completed. Results are available in S3.",
    "downloadEndpoint": p('api.base.path') ++ "/query/ctas/" ++ vars.outputTable ++ "/download"
}]]></ee:set-payload>
                </ee:message>
            </ee:transform>
    </flow>

    <!-- CTAS Download Flow -->
    <flow name="ctasDownloadFlow" doc:name="ctasDownloadFlow">
        <http:listener path="#[p('api.base.path')]/query/ctas/{tableName}/download" 
                       config-ref="HTTP_Listener_config" 
                       allowedMethods="GET" 
                       doc:name="CTAS Download Endpoint"/>
        
        <ee:transform doc:name="Extract Parameters">
            <ee:message>
                <ee:set-variable variableName="downloadMode"><![CDATA[%dw 2.0
output application/java
---
attributes.queryParams.download default "false"]]></ee:set-variable>
                <ee:set-variable variableName="presignedUrlMode"><![CDATA[%dw 2.0
output application/java
---
attributes.queryParams.presignedUrl default "false"]]></ee:set-variable>
                <ee:set-variable variableName="fileKey"><![CDATA[%dw 2.0
output application/java
---
attributes.queryParams.fileKey default ""]]></ee:set-variable>
                <ee:set-variable variableName="s3Path"><![CDATA[%dw 2.0
output application/java
---
p('aws.s3.output.location') ++ attributes.uriParams.tableName ++ "/"]]></ee:set-variable>
                <ee:set-variable variableName="bucketName"><![CDATA[%dw 2.0
output application/java
---
vars.s3Path splitBy('/')[1]]]></ee:set-variable>
                <ee:set-variable variableName="prefix"><![CDATA[%dw 2.0
output application/java
---
vars.s3Path substringAfter(vars.s3Path splitBy('/')[1] ++ '/')]]></ee:set-variable>
            </ee:message>
        </ee:transform>

        <choice doc:name="Download Mode">
            <when expression="#[vars.downloadMode == 'true' and vars.fileKey != empty]">
                <!-- Direct file download -->
                <aws-s3:get-object config-ref="AWS_S3_Config"
                                   bucketName="#[vars.bucketName]"
                                   key="#[vars.fileKey]"
                                   outputMimeType="application/octet-stream"
                                   doc:name="Download File from S3"/>
                <ee:transform doc:name="Set Download Headers">
                    <ee:message>
                        <ee:set-variable variableName="fileName"><![CDATA[%dw 2.0
output application/java
---
vars.fileKey splitBy('/')[-1]]]></ee:set-variable>
                        <ee:set-payload>#[payload]</ee:set-payload>
                        <ee:set-attributes><![CDATA[%dw 2.0
output application/java
---
{
    "Content-Type": "application/octet-stream",
    "Content-Disposition": "attachment; filename=\"" ++ vars.fileName ++ "\""
}]]></ee:set-attributes>
                    </ee:message>
                </ee:transform>
            </when>
            <when expression="#[vars.presignedUrlMode == 'true' and vars.fileKey != empty]">
                <!-- Generate presigned URL -->
                <aws-s3:generate-presigned-url config-ref="AWS_S3_Config"
                                              bucketName="#[vars.bucketName]"
                                              key="#[vars.fileKey]"
                                              expirationInSeconds="900"
                                              doc:name="Generate Presigned URL"/>
                <ee:transform doc:name="Format Presigned URL Response">
                    <ee:message>
                        <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    "tableName": attributes.uriParams.tableName,
    "fileKey": vars.fileKey,
    "presignedUrl": payload,
    "expirationSeconds": 900,
    "message": "Use this URL to download the file directly from S3. URL expires in 15 minutes."
}]]></ee:set-payload>
                        </ee:message>
                    </ee:transform>
            </when>
            <otherwise>
                <!-- Default: List files -->
                <aws-s3:list-objects config-ref="AWS_S3_Config" 
                                     bucketName="#[vars.bucketName]" 
                                     prefix="#[vars.prefix]" 
                                     doc:name="List S3 Objects"/>

                <ee:transform doc:name="Format Download Response">
                    <ee:message>
                        <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    "tableName": attributes.uriParams.tableName,
    "s3Location": vars.s3Path,
    "files": payload map (file) -> {
        "key": file.Key,
        "size": file.Size,
        "lastModified": file.LastModified,
        "downloadUrl": p('api.base.path') ++ "/query/ctas/" ++ attributes.uriParams.tableName ++ "/download?download=true&fileKey=" ++ (file.Key replace / / with "%20"),
        "presignedUrlEndpoint": p('api.base.path') ++ "/query/ctas/" ++ attributes.uriParams.tableName ++ "/download?presignedUrl=true&fileKey=" ++ (file.Key replace / / with "%20")
    },
    "instructions": {
        "download": "Add ?download=true&fileKey=<fileKey> to download file directly",
        "presignedUrl": "Add ?presignedUrl=true&fileKey=<fileKey> to get presigned URL for direct S3 access"
    }
}]]></ee:set-payload>
                        </ee:message>
                    </ee:transform>
            </otherwise>
        </choice>
    </flow>

    <!-- Transactional Flow (Iceberg) -->
    <flow name="transactionalFlow" doc:name="transactionalFlow">
        <http:listener path="#[p('api.base.path')]/transaction" 
                       config-ref="HTTP_Listener_config" 
                       allowedMethods="POST" 
                       doc:name="Transactional Endpoint"/>
        
        <ee:transform doc:name="Extract and Validate Parameters">
            <ee:message>
                <ee:set-variable variableName="tableName"><![CDATA[%dw 2.0
output application/java
---
payload.tableName default p('athena.table.transactional')]]></ee:set-variable>
                <ee:set-variable variableName="operations"><![CDATA[%dw 2.0
output application/java
---
payload.operations default []]]></ee:set-variable>
                <ee:set-variable variableName="validationErrors"><![CDATA[%dw 2.0
output application/java
---
do {
    var errors = []
    
    // Validate table name (basic SQL injection prevention)
    if (vars.tableName != empty)
        if (vars.tableName contains ";" or vars.tableName contains "--" or vars.tableName contains "/*")
            errors = errors + "Table name contains invalid characters"
    
    // Validate operations array
    if (sizeOf(vars.operations) == 0)
        errors = errors + "At least one operation is required"
    
    if (sizeOf(vars.operations) > 50)
        errors = errors + "Maximum of 50 operations allowed per transaction"
    
    // Validate each operation (basic checks)
    var invalidOps = vars.operations filter (op) -> 
        sizeOf(op) > 10000 or 
        (upper(op) contains "DROP" or upper(op) contains "TRUNCATE" or upper(op) contains "ALTER")
    
    if (sizeOf(invalidOps) > 0)
        errors = errors + "Operations contain invalid or dangerous SQL statements"
    
    errors
}]]></ee:set-variable>
            </ee:message>
        </ee:transform>

        <choice doc:name="Check Validation Errors">
            <when expression="#[sizeOf(vars.validationErrors) > 0]">
                <ee:transform doc:name="Validation Error Response">
                    <ee:message>
                        <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    "error": "VALIDATION_ERROR",
    "message": "Input validation failed",
    "errors": vars.validationErrors,
    "errorCode": "INVALID_INPUT"
}]]></ee:set-payload>
                        </ee:message>
                        <ee:set-status-code value="400"/>
                    </ee:transform>
            </when>
        </choice>

        <ee:transform doc:name="Build Transaction Query">
            <ee:message>
                <ee:set-variable variableName="tableName"><![CDATA[%dw 2.0
output application/java
---
vars.tableName]]></ee:set-variable>
                <ee:set-variable variableName="operations"><![CDATA[%dw 2.0
output application/java
---
vars.operations]]></ee:set-variable>
                <ee:set-variable variableName="transactionQuery"><![CDATA[%dw 2.0
output application/java
---
"START TRANSACTION;\n" ++ 
(vars.operations joinBy ";\n") ++ 
";\nCOMMIT;"]]></ee:set-variable>
            </ee:message>
        </ee:transform>

        <db:execute config-ref="AthenaDatabaseConfig" doc:name="Execute Transaction">
            <db:sql>#[vars.transactionQuery]</db:sql>
        </db:execute>

        <ee:transform doc:name="Format Transaction Response">
            <ee:message>
                <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    "status": "SUCCESS",
    "message": "Transaction committed successfully",
    "tableName": vars.tableName,
    "operationsCount": sizeOf(vars.operations)
}]]></ee:set-payload>
                </ee:message>
            </ee:transform>

        <error-handler>
            <on-error-continue type="DB:QUERY_EXECUTION" logException="true" doc:name="Transaction Error">
                <logger level="ERROR" message="Transaction failed: #[error.description]" doc:name="Log Transaction Error"/>
                <db:execute-script config-ref="AthenaDatabaseConfig" doc:name="Rollback Transaction">
                    <db:sql>ROLLBACK;</db:sql>
                </db:execute-script>
                <ee:transform doc:name="Transaction Error Response">
                    <ee:message>
                        <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    "status": "FAILED",
    "error": "TRANSACTION_ERROR",
    "errorCode": "ICEBERG_TRANSACTION_ROLLED_BACK",
    "message": "Transaction was rolled back. ROLLBACK command executed to clean up Iceberg snapshot.",
    "details": error.cause.message default "",
    "troubleshooting": [
        "Transaction automatically rolled back - no manual action needed",
        "Check individual operation syntax and data validity",
        "Verify table exists and is an Iceberg table (not Parquet/CSV)",
        "Check for concurrent transaction conflicts",
        "Review S3 metadata location accessibility",
        "Ensure all operations in transaction are valid DML statements"
    ],
    "documentation": "See README: Transactional Operations section and Troubleshooting: Iceberg Snapshot Lock"
}]]></ee:set-payload>
                        </ee:message>
                        <ee:set-status-code value="500"/>
                    </ee:transform>
                </on-error-continue>
        </error-handler>
    </flow>

    <!-- Analytical Flow (Parquet) -->
    <flow name="analyticalFlow" doc:name="analyticalFlow">
        <http:listener path="#[p('api.base.path')]/analytics" 
                       config-ref="HTTP_Listener_config" 
                       allowedMethods="POST" 
                       doc:name="Analytical Endpoint"/>
        
        <ee:transform doc:name="Extract and Validate Parameters">
            <ee:message>
                <ee:set-variable variableName="tableName"><![CDATA[%dw 2.0
output application/java
---
payload.tableName default p('athena.table.analytical')]]></ee:set-variable>
                <ee:set-variable variableName="validationErrors"><![CDATA[%dw 2.0
output application/java
---
do {
    var errors = []
    
    // Validate table name (basic SQL injection prevention)
    if (vars.tableName != empty)
        if (vars.tableName contains ";" or vars.tableName contains "--" or vars.tableName contains "/*")
            errors = errors + "Table name contains invalid characters"
    
    // Validate limit if provided
    var limit = payload.limit default p('pagination.defaultLimit')
    var maxLimit = p('pagination.maxLimit') as Number
    if (limit as Number? != null)
        if (limit as Number <= 0)
            errors = errors + "Limit must be a positive number"
        else if (limit as Number > maxLimit)
            errors = errors + "Limit exceeds maximum of " ++ maxLimit
    
    // Validate lastSeenId format if provided
    var lastSeenId = payload.lastSeenId default ""
    if (lastSeenId != empty and lastSeenId != null)
        if (lastSeenId as Number? == null)
            errors = errors + "lastSeenId must be a numeric value"
    
    errors
}]]></ee:set-variable>
            </ee:message>
        </ee:transform>

        <choice doc:name="Check Validation Errors">
            <when expression="#[sizeOf(vars.validationErrors) > 0]">
                <ee:transform doc:name="Validation Error Response">
                    <ee:message>
                        <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    "error": "VALIDATION_ERROR",
    "message": "Input validation failed",
    "errors": vars.validationErrors,
    "errorCode": "INVALID_INPUT"
}]]></ee:set-payload>
                        </ee:message>
                        <ee:set-status-code value="400"/>
                    </ee:transform>
            </when>
        </choice>

        <ee:transform doc:name="Build Optimized Query">
            <ee:message>
                <ee:set-variable variableName="tableName"><![CDATA[%dw 2.0
output application/java
---
vars.tableName]]></ee:set-variable>
                <ee:set-variable variableName="columns"><![CDATA[%dw 2.0
output application/java
---
payload.columns default "*"]]></ee:set-variable>
                <ee:set-variable variableName="partitionFilter"><![CDATA[%dw 2.0
output application/java
---
payload.partitionFilter default ""]]></ee:set-variable>
                <ee:set-variable variableName="whereClause"><![CDATA[%dw 2.0
output application/java
---
payload.whereClause default ""]]></ee:set-variable>
                <ee:set-variable variableName="lastSeenId"><![CDATA[%dw 2.0
output application/java
---
payload.lastSeenId default ""]]></ee:set-variable>
                <ee:set-variable variableName="limit"><![CDATA[%dw 2.0
output application/java
---
payload.limit default p('pagination.defaultLimit')]]></ee:set-variable>
                <ee:set-variable variableName="idColumn"><![CDATA[%dw 2.0
output application/java
---
p('pagination.idColumn')]]></ee:set-variable>
                <ee:set-variable variableName="optimizedQuery"><![CDATA[%dw 2.0
output application/java
---
do {
    var baseWhere = if (vars.partitionFilter != empty) 
        " WHERE " ++ vars.partitionFilter 
    else 
        ""
    
    var whereWithClause = if (vars.whereClause != empty)
        if (vars.partitionFilter != empty)
            baseWhere ++ " AND " ++ vars.whereClause
        else
            " WHERE " ++ vars.whereClause
    else
        baseWhere
    
    var whereWithCursor = if (vars.lastSeenId != empty and vars.lastSeenId != null)
        if (whereWithClause != "")
            whereWithClause ++ " AND " ++ vars.idColumn ++ " > " ++ vars.lastSeenId
        else
            " WHERE " ++ vars.idColumn ++ " > " ++ vars.lastSeenId
    else
        whereWithClause
    
    var queryWithOrder = "SELECT " ++ vars.columns ++ " FROM " ++ vars.tableName ++ whereWithCursor ++ 
        " ORDER BY " ++ vars.idColumn ++ 
        " LIMIT " ++ vars.limit
    
    queryWithOrder
}]]></ee:set-variable>
            </ee:message>
        </ee:transform>

        <choice doc:name="Validate Partition Filter">
            <when expression="#[vars.partitionFilter == empty and vars.tableName contains 'parquet']">
                <logger level="WARN" message="Warning: Query without partition filter may result in full table scan and high costs" doc:name="Log Partition Warning"/>
            </when>
        </choice>

        <db:select config-ref="AthenaDatabaseConfig" doc:name="Execute Analytical Query">
            <db:sql>#[vars.optimizedQuery]</db:sql>
        </db:select>

        <ee:transform doc:name="Format Analytical Response">
            <ee:message>
                <ee:set-variable variableName="lastRowId"><![CDATA[%dw 2.0
output application/java
---
if (sizeOf(payload) > 0)
    payload[-1][vars.idColumn] default payload[-1][upper(vars.idColumn)] default ""
else
    ""]]></ee:set-variable>
                <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    "status": "SUCCESS",
    "query": vars.optimizedQuery,
    "tableName": vars.tableName,
    "rowCount": sizeOf(payload),
    "results": payload,
    "lastSeenId": vars.lastRowId,
    "hasMore": sizeOf(payload) == vars.limit,
    "optimization": {
        "partitionFilterUsed": vars.partitionFilter != empty,
        "columnsSelected": vars.columns != "*",
        "cursorPaginationUsed": vars.lastSeenId != empty and vars.lastSeenId != null
    }
}]]></ee:set-payload>
                </ee:message>
            </ee:transform>
    </flow>
  
</mule>
